name: Roadmap Sync

on:
  # Manual trigger
  workflow_dispatch:

  # Scheduled sync (every 30 minutes)
  schedule:
    - cron: "*/30 * * * *"

  # Trigger on issue/project changes
  issues:
    types: [opened, edited, closed, labeled, unlabeled]

  project:
    types: [closed, edited, reopened]

# Prevent concurrent syncs
concurrency:
  group: roadmap-sync
  cancel-in-progress: true

permissions:
  contents: write
  issues: read
  repository-projects: read

jobs:
  sync:
    name: Sync Roadmap to CDN
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: roadmap-data
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      # ============================================================
      # Step 1: Load previous roadmap.json as cache for friendly_title
      # ============================================================
      - name: Load Cached Titles
        id: cache
        run: |
          if [ -f roadmap.json ]; then
            echo "Found existing roadmap.json, loading as cache..."
            cat roadmap.json | jq -c '.items | map({(.id|tostring): {title: .title, friendly_title: .friendly_title}}) | add // {}' > title_cache.json
            echo "cache_found=true" >> $GITHUB_OUTPUT
          else
            echo "No previous roadmap.json found"
            echo "{}" > title_cache.json
            echo "cache_found=false" >> $GITHUB_OUTPUT
          fi

      # ============================================================
      # Step 2: Fetch Roadmap Data from GitHub Projects
      # ============================================================
      - name: Fetch Roadmap Data
        id: fetch
        uses: actions/github-script@v7
        env:
          PROJECT_NUMBER: 2
          ORG_NAME: "down-kingo"
        with:
          github-token: ${{ secrets.ROADMAP_PAT }}
          script: |
            const projectNumber = parseInt(process.env.PROJECT_NUMBER);
            const orgName = process.env.ORG_NAME;
            const fs = require('fs');

            console.log(`Fetching Project V2 #${projectNumber} from ${orgName}...`);

            const query = `
              query($login: String!, $number: Int!) {
                organization(login: $login) {
                  projectV2(number: $number) {
                    items(first: 100) {
                      nodes {
                        content {
                          ... on Issue {
                            number
                            title
                            body
                            url
                            state
                            closedAt
                            comments { totalCount }
                            reactions(content: THUMBS_UP) { totalCount }
                            reactions_down: reactions(content: THUMBS_DOWN) { totalCount }
                            labels(first: 10) { nodes { name } }
                            author { login, avatarUrl }
                            createdAt
                          }
                        }
                        fieldValueByName(name: "Status") {
                          ... on ProjectV2ItemFieldSingleSelectValue { name }
                        }
                      }
                    }
                  }
                }
              }
            `;

            const result = await github.graphql(query, {
              login: orgName,
              number: projectNumber
            });

            const nodes = result.organization?.projectV2?.items?.nodes || [];
            console.log(`Found ${nodes.length} items`);

            // Load cached titles
            let titleCache = {};
            try {
              const cacheContent = fs.readFileSync('title_cache.json', 'utf8');
              titleCache = JSON.parse(cacheContent) || {};
              console.log(`Loaded ${Object.keys(titleCache).length} cached titles`);
            } catch (e) {
              console.log('No cache file found, starting fresh');
            }

            // Map status names to our enum
            const statusMapping = {
              'bastidores': 'idea',
              'em pauta': 'planned',
              'em produção': 'in-progress',
              'no ar': 'shipped',
              'backlog': 'idea',
              'todo': 'idea',
              'ready': 'planned',
              'planned': 'planned',
              'in progress': 'in-progress',
              'done': 'shipped',
              'shipped': 'shipped',
              'completed': 'shipped'
            };

            // Process items - mark which need Gemini processing
            const items = nodes
              .filter(node => node.content?.number)
              .map(node => {
                const c = node.content;
                const statusName = node.fieldValueByName?.name?.toLowerCase() || 'idea';
                const status = statusMapping[statusName] || 'idea';
                
                // Description (Full Markdown)
                let description = c.body || '';
                
                // Check cache: reuse friendly_title if title unchanged
                const cached = titleCache[String(c.number)];
                let friendly_title = null;
                let needs_ai = false;
                
                if (cached && cached.title === c.title && cached.friendly_title) {
                  // Title unchanged and we have cached friendly_title - reuse it
                  friendly_title = cached.friendly_title;
                  console.log(`[CACHE HIT] Issue #${c.number}: "${friendly_title}"`);
                } else {
                  // New item or title changed - needs AI processing
                  needs_ai = true;
                  console.log(`[CACHE MISS] Issue #${c.number}: "${c.title}"`);
                }
                

                
                return {
                  id: c.number,
                  title: c.title,
                  friendly_title,
                  needs_ai,
                  description,
                  status,
                  votes_up: c.reactions?.totalCount || 0,
                  votes_down: c.reactions_down?.totalCount || 0,
                  comments: c.comments?.totalCount || 0,
                  url: c.url,
                  labels: (c.labels?.nodes || []).map(l => l.name),
                  author: c.author?.login || '',
                  author_avatar: c.author?.avatarUrl || '',
                  created_at: c.createdAt,
                  shipped_at: c.state === 'CLOSED' ? c.closedAt : null
                };
              });

            // Sort: shipped to bottom, rest by votes
            items.sort((a, b) => {
              if (a.status === 'shipped' && b.status === 'shipped') {
                return b.id - a.id;
              }
              if (a.status === 'shipped') return 1;
              if (b.status === 'shipped') return -1;
              return b.votes_up - a.votes_up;
            });

            // Count items needing AI
            const needsAiCount = items.filter(i => i.needs_ai).length;
            console.log(`${needsAiCount} items need AI processing`);

            // Save intermediate items for AI step
            fs.writeFileSync('items_raw.json', JSON.stringify(items, null, 2));

            core.setOutput('items_count', items.length);
            core.setOutput('needs_ai_count', needsAiCount);

            console.log(`Processed ${items.length} roadmap items`);

      # ============================================================
      # Step 3: Generate friendly_title via Gemini API (only for new/changed)
      # ============================================================
      - name: Generate Friendly Titles (Gemini)
        if: steps.fetch.outputs.needs_ai_count != '0'
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          echo "Processing ${{ steps.fetch.outputs.needs_ai_count }} items with Gemini..."

          # Read items
          ITEMS=$(cat items_raw.json)

          # Process each item that needs AI
          echo "$ITEMS" | jq -c '.[]' | while read -r item; do
            NEEDS_AI=$(echo "$item" | jq -r '.needs_ai')
            if [ "$NEEDS_AI" != "true" ]; then
              continue
            fi
            
            ID=$(echo "$item" | jq -r '.id')
            TITLE=$(echo "$item" | jq -r '.title')
            
            echo "Processing issue #$ID: $TITLE"
            
            # Build Gemini prompt
            PROMPT="Transforme o título técnico abaixo em um título amigável em português brasileiro.
          Regras:
          - Remova prefixos como feat(), fix(), chore(), docs(), etc.
          - Seja claro e direto (máximo 60 caracteres)
          - Não use pontuação final
          - Mantenha o significado original

          Título técnico: $TITLE

          Responda APENAS com o título amigável, nada mais."
            
            # Escape for JSON
            PROMPT_ESCAPED=$(echo "$PROMPT" | jq -Rs '.')
            
            # Call Gemini API
            RESPONSE=$(curl -s -X POST \
              "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=$GEMINI_API_KEY" \
              -H "Content-Type: application/json" \
              -d "{
                \"contents\": [{
                  \"parts\": [{\"text\": $PROMPT_ESCAPED}]
                }],
                \"generationConfig\": {
                  \"temperature\": 0.3,
                  \"maxOutputTokens\": 100
                }
              }")
            
            # Extract generated text
            FRIENDLY_TITLE=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // empty' | tr -d '\n' | head -c 100)
            
            if [ -n "$FRIENDLY_TITLE" ]; then
              echo "  -> $FRIENDLY_TITLE"
              # Update item in JSON file
              jq --arg id "$ID" --arg ft "$FRIENDLY_TITLE" \
                '(.[] | select(.id == ($id | tonumber))).friendly_title = $ft' \
                items_raw.json > items_tmp.json && mv items_tmp.json items_raw.json
            else
              echo "  -> [Gemini returned empty, using fallback]"
              # Fallback: remove feat()/fix() prefix manually
              FALLBACK=$(echo "$TITLE" | sed -E 's/^(feat|fix|chore|docs|refactor|style|test|ci)\([^)]*\):\s*//')
              jq --arg id "$ID" --arg ft "$FALLBACK" \
                '(.[] | select(.id == ($id | tonumber))).friendly_title = $ft' \
                items_raw.json > items_tmp.json && mv items_tmp.json items_raw.json
            fi
            
            # Rate limit: 1 request per second (Gemini has generous limits but be polite)
            sleep 1
          done

          echo "AI processing complete!"

      # ============================================================
      # Step 4: Fallback for items that still have no friendly_title
      # ============================================================
      - name: Apply Fallback Titles
        run: |
          # For any item without friendly_title, use cleaned title as fallback
          jq '
            .[] |
            if .friendly_title == null or .friendly_title == "" then
              .friendly_title = (.title | gsub("^(feat|fix|chore|docs|refactor|style|test|ci)\\([^)]*\\):\\s*"; ""))
            else
              .
            end
          ' items_raw.json | jq -s '.' > items_processed.json

          # Remove the needs_ai flag (internal use only)
          jq 'map(del(.needs_ai))' items_processed.json > items_clean.json

      # ============================================================
      # Step 5: Generate final roadmap.json and roadmap.meta.json
      # ============================================================
      - name: Generate Files
        run: |
          # Build final roadmap.json
          jq -n \
            --arg version "1.0.0" \
            --arg generated_at "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --arg owner "down-kingo" \
            --arg repo "downkingo" \
            --argjson project_number 2 \
            --slurpfile items items_clean.json \
            '{
              version: $version,
              generated_at: $generated_at,
              source: {
                owner: $owner,
                repo: $repo,
                project_number: $project_number
              },
              items: $items[0]
            }' > roadmap.json

          # Compute SHA256 hash
          HASH=$(sha256sum roadmap.json | cut -d' ' -f1)

          # Create roadmap.meta.json
          ITEMS_COUNT=$(jq '.items | length' roadmap.json)
          cat > roadmap.meta.json << EOF
          {
            "version": "1.0.0",
            "generated_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "items_count": $ITEMS_COUNT,
            "content_hash": "sha256:${HASH}"
          }
          EOF

          # Cleanup temp files
          rm -f items_raw.json items_processed.json items_clean.json title_cache.json

          echo "Generated files:"
          ls -la *.json
          echo ""
          echo "Sample item:"
          jq '.items[0]' roadmap.json
          echo ""
          echo "Meta content:"
          cat roadmap.meta.json

      # ============================================================
      # Step 6: Commit and Push
      # ============================================================
      - name: Commit Changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if files changed
          if git diff --quiet roadmap.json roadmap.meta.json 2>/dev/null; then
            echo "No changes detected, skipping commit"
            exit 0
          fi

          git add roadmap.json roadmap.meta.json
          git commit -m "chore: sync roadmap $(date +%Y-%m-%d)"
          git push

      - name: Trigger Cloudflare Pages Deploy
        if: success()
        run: |
          echo "Cloudflare Pages will auto-deploy from the roadmap-data branch"
          echo "URL: https://downkingo-roadmap.pages.dev/"
