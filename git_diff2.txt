diff --git a/app.go b/app.go
index c9aa55e..964406c 100644
--- a/app.go
+++ b/app.go
@@ -25,10 +25,23 @@ import (
 	"os"
 	"strings"
 	"sync"
+	"time"
 
 	"github.com/wailsapp/wails/v3/pkg/application"
 )
 
+// proxyHTTPClient is a shared HTTP client for the proxy server.
+// Reused across requests to leverage connection pooling and avoid per-request allocations.
+var proxyHTTPClient = &http.Client{
+	Timeout: 60 * time.Second,
+	Transport: &http.Transport{
+		MaxIdleConns:        10,
+		IdleConnTimeout:     90 * time.Second,
+		DisableCompression:  true, // streams are already compressed
+		MaxConnsPerHost:     5,
+	},
+}
+
 // Version is set at build time via ldflags, or read from the embedded VERSION file.
 var Version string
 
@@ -201,9 +214,10 @@ func (a *App) startClipboardMonitor(ctx context.Context) {
 
 // initializeHandlers creates and configures all business logic handlers.
 func (a *App) initializeHandlers(ctx context.Context) {
-	a.videoHandler = handlers.NewVideoHandler(a.youtube, a.downloadManager)
-	a.videoHandler.SetContext(ctx)
-	a.videoHandler.SetConsoleEmitter(a.consoleLog)
+	a.videoHandler = handlers.NewVideoHandler(a.youtube, a.downloadManager,
+		handlers.WithContext(ctx),
+		handlers.WithConsoleEmitter(a.consoleLog),
+	)
 
 	a.mediaHandler = handlers.NewMediaHandler(a.imageClient, a.youtube)
 	a.mediaHandler.SetContext(ctx)
@@ -264,8 +278,7 @@ func (a *App) startProxyServer() {
 			req.Header.Set("Range", rangeHeader)
 		}
 
-		client := &http.Client{}
-		resp, err := client.Do(req)
+		resp, err := proxyHTTPClient.Do(req)
 		if err != nil {
 			http.Error(w, "failed to fetch stream", http.StatusBadGateway)
 			return
@@ -696,16 +709,39 @@ func (a *App) GetUserReactions() (map[int]string, error) {
 		}
 	}
 
-	reactions := make(map[int]string)
+	// Fetch reactions concurrently with bounded parallelism
+	type result struct {
+		id       int
+		reaction string
+	}
+
+	results := make(chan result, len(items))
+	sem := make(chan struct{}, 5) // Max 5 concurrent API calls
+
+	var wg sync.WaitGroup
 	for _, item := range items {
-		reaction, err := a.roadmap.GetUserReaction(a.auth.Token, item.ID)
-		if err != nil {
-			// Log but continue - don't fail the whole batch for one item
-			continue
-		}
-		if reaction != "" {
-			reactions[item.ID] = reaction
-		}
+		wg.Add(1)
+		go func(issueID int) {
+			defer wg.Done()
+			sem <- struct{}{}        // Acquire
+			defer func() { <-sem }() // Release
+
+			reaction, err := a.roadmap.GetUserReaction(a.auth.Token, issueID)
+			if err != nil || reaction == "" {
+				return
+			}
+			results <- result{id: issueID, reaction: reaction}
+		}(item.ID)
+	}
+
+	go func() {
+		wg.Wait()
+		close(results)
+	}()
+
+	reactions := make(map[int]string)
+	for r := range results {
+		reactions[r.id] = r.reaction
 	}
 
 	return reactions, nil
diff --git a/frontend/bun.lock b/frontend/bun.lock
index 0bc3c2c..a9af6e5 100644
--- a/frontend/bun.lock
+++ b/frontend/bun.lock
@@ -39,6 +39,7 @@
         "jsdom": "^27.4.0",
         "postcss": "^8.4.32",
         "tailwindcss": "^3.4.0",
+        "terser": "^5.46.0",
         "typescript": "^5.9.3",
         "typescript-eslint": "^8.52.0",
         "vite": "^5.0.10",
@@ -209,6 +210,8 @@
 
     "@jridgewell/resolve-uri": ["@jridgewell/resolve-uri@3.1.2", "", {}, "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw=="],
 
+    "@jridgewell/source-map": ["@jridgewell/source-map@0.3.11", "", { "dependencies": { "@jridgewell/gen-mapping": "^0.3.5", "@jridgewell/trace-mapping": "^0.3.25" } }, "sha512-ZMp1V8ZFcPG5dIWnQLr3NSI1MiCU7UETdS/A0G8V/XWHvJv3ZsFqutJn1Y5RPmAPX6F3BiE397OqveU/9NCuIA=="],
+
     "@jridgewell/sourcemap-codec": ["@jridgewell/sourcemap-codec@1.5.5", "", {}, "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og=="],
 
     "@jridgewell/trace-mapping": ["@jridgewell/trace-mapping@0.3.31", "", { "dependencies": { "@jridgewell/resolve-uri": "^3.1.0", "@jridgewell/sourcemap-codec": "^1.4.14" } }, "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw=="],
@@ -443,6 +446,8 @@
 
     "buffer": ["buffer@6.0.3", "", { "dependencies": { "base64-js": "^1.3.1", "ieee754": "^1.2.1" } }, "sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA=="],
 
+    "buffer-from": ["buffer-from@1.1.2", "", {}, "sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ=="],
+
     "call-bind": ["call-bind@1.0.8", "", { "dependencies": { "call-bind-apply-helpers": "^1.0.0", "es-define-property": "^1.0.0", "get-intrinsic": "^1.2.4", "set-function-length": "^1.2.2" } }, "sha512-oKlSFMcMwpUg2ednkhQ454wfWiU/ul3CkJe/PEHcTKuiX6RpbehUiFMXu13HalGZxfUwCQzZG747YXBn1im9ww=="],
 
     "call-bind-apply-helpers": ["call-bind-apply-helpers@1.0.2", "", { "dependencies": { "es-errors": "^1.3.0", "function-bind": "^1.1.2" } }, "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ=="],
@@ -1177,8 +1182,12 @@
 
     "sort-keys": ["sort-keys@5.1.0", "", { "dependencies": { "is-plain-obj": "^4.0.0" } }, "sha512-aSbHV0DaBcr7u0PVHXzM6NbZNAtrr9sF6+Qfs9UUVG7Ll3jQ6hHi8F/xqIIcn2rvIVbr0v/2zyjSdwSV47AgLQ=="],
 
+    "source-map": ["source-map@0.6.1", "", {}, "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g=="],
+
     "source-map-js": ["source-map-js@1.2.1", "", {}, "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA=="],
 
+    "source-map-support": ["source-map-support@0.5.21", "", { "dependencies": { "buffer-from": "^1.0.0", "source-map": "^0.6.0" } }, "sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w=="],
+
     "space-separated-tokens": ["space-separated-tokens@2.0.2", "", {}, "sha512-PEGlAwrG8yXGXRjW32fGbg66JAlOAwbObuqVoJpv/mRgoWDQfgH1wDPvtzWyUSNAXBGSk8h755YDbbcEy3SH2Q=="],
 
     "sprintf-js": ["sprintf-js@1.1.3", "", {}, "sha512-Oo+0REFV59/rz3gfJNKQiBlwfHaSESl1pcGyABQsnnIfWOFt6JNj5gCog2U6MLZ//IGYD+nA8nI+mTShREReaA=="],
@@ -1237,6 +1246,8 @@
 
     "teex": ["teex@1.0.1", "", { "dependencies": { "streamx": "^2.12.5" } }, "sha512-eYE6iEI62Ni1H8oIa7KlDU6uQBtqr4Eajni3wX7rpfXD8ysFx8z0+dri+KWEPWpBsxXfxu58x/0jvTVT1ekOSg=="],
 
+    "terser": ["terser@5.46.0", "", { "dependencies": { "@jridgewell/source-map": "^0.3.3", "acorn": "^8.15.0", "commander": "^2.20.0", "source-map-support": "~0.5.20" }, "bin": { "terser": "bin/terser" } }, "sha512-jTwoImyr/QbOWFFso3YoU3ik0jBBDJ6JTOQiy/J2YxVJdZCc+5u7skhNwiOR3FQIygFqVUPHl7qbbxtjW2K3Qg=="],
+
     "text-decoder": ["text-decoder@1.2.3", "", { "dependencies": { "b4a": "^1.6.4" } }, "sha512-3/o9z3X0X0fTupwsYvR03pJ/DjWuqqrfwBgTQzdWDiQSm9KitAyz/9WqsT2JQW7KV2m+bC2ol/zqpW37NHxLaA=="],
 
     "thenify": ["thenify@3.3.1", "", { "dependencies": { "any-promise": "^1.0.0" } }, "sha512-RVZSIV5IG10Hk3enotrhvz0T9em6cyHBLkH/YAZuKqd8hRkKhSfCGIcP2KUY0EPxndzANBmNllzWPwak+bheSw=="],
@@ -1465,6 +1476,8 @@
 
     "tailwindcss/resolve": ["resolve@1.22.11", "", { "dependencies": { "is-core-module": "^2.16.1", "path-parse": "^1.0.7", "supports-preserve-symlinks-flag": "^1.0.0" }, "bin": { "resolve": "bin/resolve" } }, "sha512-RfqAvLnMl313r7c9oclB1HhUEAezcpLjz95wFH4LVuhk9JF/r22qmVP9AMmOU4vMX7Q8pN8jwNg/CSpdFnMjTQ=="],
 
+    "terser/commander": ["commander@2.20.3", "", {}, "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ=="],
+
     "vite/esbuild": ["esbuild@0.21.5", "", { "optionalDependencies": { "@esbuild/aix-ppc64": "0.21.5", "@esbuild/android-arm": "0.21.5", "@esbuild/android-arm64": "0.21.5", "@esbuild/android-x64": "0.21.5", "@esbuild/darwin-arm64": "0.21.5", "@esbuild/darwin-x64": "0.21.5", "@esbuild/freebsd-arm64": "0.21.5", "@esbuild/freebsd-x64": "0.21.5", "@esbuild/linux-arm": "0.21.5", "@esbuild/linux-arm64": "0.21.5", "@esbuild/linux-ia32": "0.21.5", "@esbuild/linux-loong64": "0.21.5", "@esbuild/linux-mips64el": "0.21.5", "@esbuild/linux-ppc64": "0.21.5", "@esbuild/linux-riscv64": "0.21.5", "@esbuild/linux-s390x": "0.21.5", "@esbuild/linux-x64": "0.21.5", "@esbuild/netbsd-x64": "0.21.5", "@esbuild/openbsd-x64": "0.21.5", "@esbuild/sunos-x64": "0.21.5", "@esbuild/win32-arm64": "0.21.5", "@esbuild/win32-ia32": "0.21.5", "@esbuild/win32-x64": "0.21.5" }, "bin": { "esbuild": "bin/esbuild" } }, "sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw=="],
 
     "vitest/vite": ["vite@7.3.0", "", { "dependencies": { "esbuild": "^0.27.0", "fdir": "^6.5.0", "picomatch": "^4.0.3", "postcss": "^8.5.6", "rollup": "^4.43.0", "tinyglobby": "^0.2.15" }, "optionalDependencies": { "fsevents": "~2.3.3" }, "peerDependencies": { "@types/node": "^20.19.0 || >=22.12.0", "jiti": ">=1.21.0", "less": "^4.0.0", "lightningcss": "^1.21.0", "sass": "^1.70.0", "sass-embedded": "^1.70.0", "stylus": ">=0.54.8", "sugarss": "^5.0.0", "terser": "^5.16.0", "tsx": "^4.8.1", "yaml": "^2.4.2" }, "optionalPeers": ["@types/node", "jiti", "less", "lightningcss", "sass", "sass-embedded", "stylus", "sugarss", "terser", "tsx", "yaml"], "bin": { "vite": "bin/vite.js" } }, "sha512-dZwN5L1VlUBewiP6H9s2+B3e3Jg96D0vzN+Ry73sOefebhYr9f94wwkMNN/9ouoU8pV1BqA1d1zGk8928cx0rg=="],
diff --git a/frontend/package-lock.json b/frontend/package-lock.json
index da9ac58..d0b02c5 100644
--- a/frontend/package-lock.json
+++ b/frontend/package-lock.json
@@ -43,6 +43,7 @@
         "jsdom": "^27.4.0",
         "postcss": "^8.4.32",
         "tailwindcss": "^3.4.0",
+        "terser": "^5.46.0",
         "typescript": "^5.9.3",
         "typescript-eslint": "^8.52.0",
         "vite": "^5.0.10",
@@ -1276,6 +1277,17 @@
         "node": ">=6.0.0"
       }
     },
+    "node_modules/@jridgewell/source-map": {
+      "version": "0.3.11",
+      "resolved": "https://registry.npmjs.org/@jridgewell/source-map/-/source-map-0.3.11.tgz",
+      "integrity": "sha512-ZMp1V8ZFcPG5dIWnQLr3NSI1MiCU7UETdS/A0G8V/XWHvJv3ZsFqutJn1Y5RPmAPX6F3BiE397OqveU/9NCuIA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.5",
+        "@jridgewell/trace-mapping": "^0.3.25"
+      }
+    },
     "node_modules/@jridgewell/sourcemap-codec": {
       "version": "1.5.5",
       "dev": true,
@@ -2687,6 +2699,13 @@
         "ieee754": "^1.2.1"
       }
     },
+    "node_modules/buffer-from": {
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz",
+      "integrity": "sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/call-bind": {
       "version": "1.0.8",
       "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.8.tgz",
@@ -8731,6 +8750,16 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/source-map": {
+      "version": "0.6.1",
+      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
+      "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
     "node_modules/source-map-js": {
       "version": "1.2.1",
       "dev": true,
@@ -8739,6 +8768,17 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/source-map-support": {
+      "version": "0.5.21",
+      "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.21.tgz",
+      "integrity": "sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "buffer-from": "^1.0.0",
+        "source-map": "^0.6.0"
+      }
+    },
     "node_modules/space-separated-tokens": {
       "version": "2.0.2",
       "resolved": "https://registry.npmjs.org/space-separated-tokens/-/space-separated-tokens-2.0.2.tgz",
@@ -9174,6 +9214,32 @@
         "streamx": "^2.12.5"
       }
     },
+    "node_modules/terser": {
+      "version": "5.46.0",
+      "resolved": "https://registry.npmjs.org/terser/-/terser-5.46.0.tgz",
+      "integrity": "sha512-jTwoImyr/QbOWFFso3YoU3ik0jBBDJ6JTOQiy/J2YxVJdZCc+5u7skhNwiOR3FQIygFqVUPHl7qbbxtjW2K3Qg==",
+      "dev": true,
+      "license": "BSD-2-Clause",
+      "dependencies": {
+        "@jridgewell/source-map": "^0.3.3",
+        "acorn": "^8.15.0",
+        "commander": "^2.20.0",
+        "source-map-support": "~0.5.20"
+      },
+      "bin": {
+        "terser": "bin/terser"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/terser/node_modules/commander": {
+      "version": "2.20.3",
+      "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
+      "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/text-decoder": {
       "version": "1.2.7",
       "resolved": "https://registry.npmjs.org/text-decoder/-/text-decoder-1.2.7.tgz",
diff --git a/frontend/package.json b/frontend/package.json
index e5fa6ed..093aa03 100644
--- a/frontend/package.json
+++ b/frontend/package.json
@@ -50,6 +50,7 @@
     "jsdom": "^27.4.0",
     "postcss": "^8.4.32",
     "tailwindcss": "^3.4.0",
+    "terser": "^5.46.0",
     "typescript": "^5.9.3",
     "typescript-eslint": "^8.52.0",
     "vite": "^5.0.10",
diff --git a/frontend/src/components/TabContent.tsx b/frontend/src/components/TabContent.tsx
index 20ec9d5..5217ee9 100644
--- a/frontend/src/components/TabContent.tsx
+++ b/frontend/src/components/TabContent.tsx
@@ -1,12 +1,13 @@
 import { motion } from "framer-motion";
-import { ReactNode } from "react";
+import { memo, ReactNode } from "react";
 
 interface TabContentProps {
   children: ReactNode;
-  className?: string; // Classe extra se necess?rio
+  className?: string;
 }
 
-export const TabContent = ({ children, className }: TabContentProps) => (
+// Memoized to prevent re-renders when sibling tabs update
+export const TabContent = memo(({ children, className }: TabContentProps) => (
   <motion.div
     initial={{ opacity: 0, x: 10 }}
     animate={{ opacity: 1, x: 0 }}
@@ -18,4 +19,4 @@ export const TabContent = ({ children, className }: TabContentProps) => (
   >
     {children}
   </motion.div>
-);
+));
diff --git a/frontend/src/components/video/VideoTrimmer.tsx b/frontend/src/components/video/VideoTrimmer.tsx
index 13b636f..28ba618 100644
--- a/frontend/src/components/video/VideoTrimmer.tsx
+++ b/frontend/src/components/video/VideoTrimmer.tsx
@@ -1,4 +1,4 @@
-import { useState, useRef, useEffect, useCallback } from "react";
+import { useState, useRef, useEffect, useCallback, memo } from "react";
 import { motion, AnimatePresence } from "framer-motion";
 import { useTranslation } from "react-i18next";
 import {
@@ -38,7 +38,7 @@ function parseTimeToSeconds(time: string): number {
   return parts[0] || 0;
 }
 
-export default function VideoTrimmer({
+function VideoTrimmerInner({
   videoUrl,
   duration,
   onTrimChange,
@@ -572,3 +572,8 @@ export default function VideoTrimmer({
     </div>
   );
 }
+
+// Memoize to prevent re-renders from parent state changes (quality, mode, etc.)
+// Only re-renders when trimmer-specific props change, keeping scrubbing fluid.
+const VideoTrimmer = memo(VideoTrimmerInner);
+export default VideoTrimmer;
diff --git a/frontend/src/pages/Video.tsx b/frontend/src/pages/Video.tsx
index 7367222..4435e92 100644
--- a/frontend/src/pages/Video.tsx
+++ b/frontend/src/pages/Video.tsx
@@ -1,17 +1,18 @@
-import { useState, useEffect, useRef, lazy, Suspense } from "react";
+import { useState, useEffect, useRef, useCallback, useMemo, lazy, Suspense } from "react";
 import { motion, AnimatePresence } from "framer-motion";
 import {
   safeWindowSetDarkTheme,
   safeWindowSetLightTheme,
   safeEventsOn,
 } from "../lib/wailsRuntime";
-import { useDownloadStore, Download } from "../stores/downloadStore";
+import { useDownloadStore } from "../stores/downloadStore";
 import { useDownloadSync } from "../hooks/useDownloadSync";
 import { useShallow } from "zustand/react/shallow";
 import { useSettingsStore } from "../stores/settingsStore";
 import { useTranslation } from "react-i18next";
 import { useKeyboardShortcuts } from "../hooks/useKeyboardShortcuts";
-import { useDebounce } from "../hooks/useDebounce";
+import { useVideoFetch } from "../hooks/useVideoFetch";
+import { useTrimmer } from "../hooks/useTrimmer";
 import SettingsPanel, { SettingsTab } from "../components/SettingsPanel";
 import Terminal from "../components/Terminal";
 import OnboardingModal from "../components/OnboardingModal";
@@ -20,7 +21,6 @@ import { Sidebar, Topbar, TabType } from "../components/navigation";
 import {
   getVideoQualities,
   AUDIO_FORMATS,
-  VideoInfo,
   VideoTrimmer,
 } from "../components/video";
 const Images = lazy(() => import("./Images"));
@@ -31,52 +31,37 @@ const Dashboard = lazy(() => import("./Dashboard"));
 import { HistoryView } from "../components/HistoryView";
 import { Skeleton } from "../components/Skeleton";
 import { TabContent } from "../components/TabContent";
+import { RouteErrorBoundary } from "../components/ErrorBoundary";
 import {
   GetDownloadsPath,
   GetVersion,
-  GetVideoInfo,
-  GetStreamURL,
-  SetStreamURL,
   AddToQueueAdvanced,
   UpdateYtDlp,
   CheckForUpdate,
   InstallAppVersion,
   RestartApp,
-  OpenDownloadFolder,
-  OpenUrl,
-  CheckAria2cStatus,
-  DownloadAria2c,
 } from "../../bindings/kingo/app";
 import {
   IconDownload,
-  IconHistory,
-  IconFolder,
-  IconCheck,
   IconX,
   IconMusic,
   IconVideo,
   IconCloud,
   IconLoader2,
-  IconRefresh,
-  IconDeviceTv,
-  IconDeviceMobile,
-  IconFileMusic,
-  IconBrandApple,
-  IconVinyl,
   IconSearch,
-  IconSettings,
-  IconTrash,
-  IconPhoto,
-  IconHome,
-  IconWorld,
-  IconExternalLink,
   IconList,
-  IconTransform,
   IconRocket,
   IconBolt,
   IconArrowRight,
 } from "@tabler/icons-react";
 
+// Memoized Suspense fallback to avoid recreating on every render
+const SuspenseFallback = (
+  <div className="flex-1 flex items-center justify-center">
+    <IconLoader2 size={32} className="animate-spin text-primary-500" />
+  </div>
+);
+
 export default function Video() {
   const settings = useSettingsStore(
     useShallow((state) => ({
@@ -101,7 +86,6 @@ export default function Video() {
     theme,
     layout,
     primaryColor,
-    language,
     remuxVideo,
     remuxFormat,
     embedThumbnail,
@@ -116,13 +100,37 @@ export default function Video() {
   const enabledFeatures = useSettingsStore((s) => s.enabledFeatures);
   const { t } = useTranslation("common");
 
-  const VIDEO_QUALITIES = getVideoQualities(videoCompatibility);
+  const VIDEO_QUALITIES = useMemo(
+    () => getVideoQualities(videoCompatibility),
+    [videoCompatibility],
+  );
+
+  // Custom hooks for isolated state management
+  const {
+    url,
+    setUrl,
+    videoInfo,
+    setVideoInfo,
+    isFetching,
+    error,
+    setError,
+    handlePaste,
+    onPasteEvent,
+    clearUrl: clearUrlState,
+  } = useVideoFetch();
+
+  const {
+    trimEnabled,
+    trimStart,
+    trimEnd,
+    streamUrl,
+    handleTrimToggle,
+    handleStreamError,
+    handleTrimChange,
+    resetTrimmer,
+  } = useTrimmer(videoInfo, url);
 
-  const [url, setUrl] = useState("");
-  const [videoInfo, setVideoInfo] = useState<VideoInfo | null>(null);
   const [isLoading, setIsLoading] = useState(false);
-  const [isFetching, setIsFetching] = useState(false);
-  const [error, setError] = useState("");
   const [downloadsPath, setDownloadsPath] = useState("");
   const [version, setVersion] = useState("");
 
@@ -140,13 +148,16 @@ export default function Video() {
   };
 
   // Guard: only allow navigation to enabled tabs
-  const setActiveTab = (tab: TabType) => {
-    const requiredFeature = tabToFeature[tab];
-    if (requiredFeature && !enabledFeatures.includes(requiredFeature)) {
-      return; // Block navigation to disabled feature
-    }
-    setActiveTabRaw(tab);
-  };
+  const setActiveTab = useCallback(
+    (tab: TabType) => {
+      const requiredFeature = tabToFeature[tab];
+      if (requiredFeature && !enabledFeatures.includes(requiredFeature)) {
+        return;
+      }
+      setActiveTabRaw(tab);
+    },
+    [enabledFeatures],
+  );
 
   // Reset to home if current tab was disabled
   useEffect(() => {
@@ -163,13 +174,16 @@ export default function Video() {
     targetId?: string;
   }>({ isOpen: false });
 
-  const openSettings = (tab: SettingsTab = "general", targetId?: string) => {
-    setSettingsState({ isOpen: true, tab, targetId });
-  };
+  const openSettings = useCallback(
+    (tab: SettingsTab = "general", targetId?: string) => {
+      setSettingsState({ isOpen: true, tab, targetId });
+    },
+    [],
+  );
 
-  const closeSettings = () => {
+  const closeSettings = useCallback(() => {
     setSettingsState((prev) => ({ ...prev, isOpen: false }));
-  };
+  }, []);
 
   const inputRef = useRef<HTMLInputElement>(null);
 
@@ -209,14 +223,6 @@ export default function Video() {
   );
   const [selectedAudioFormat, setSelectedAudioFormat] = useState("mp3");
 
-  // Trimmer state
-  const [trimEnabled, setTrimEnabled] = useState(false);
-  const [trimStart, setTrimStart] = useState("");
-  const [trimEnd, setTrimEnd] = useState("");
-  const [streamUrl, setStreamUrl] = useState("");
-  const [isLoadingStream, setIsLoadingStream] = useState(false);
-  const streamFallbackTriedRef = useRef(false);
-
   // Auto-Update Logic (apenas em produ??o, rate limited 1x/dia)
   useEffect(() => {
     const isDev =
@@ -242,11 +248,8 @@ export default function Video() {
       CheckForUpdate()
         .then((info) => {
           if (info?.available) {
-            console.log("Update dispon?vel:", info.latestVersion);
             InstallAppVersion(info.latestVersion)
-              .then(() => {
-                RestartApp();
-              })
+              .then(() => RestartApp())
               .catch(() => {});
           }
         })
@@ -254,8 +257,8 @@ export default function Video() {
     }
   }, [autoUpdateYtDlp, ytDlpChannel, autoUpdateApp]);
 
-  const { queue, history } = useDownloadStore();
-  const { cancelDownload, refresh, clearHistory } = useDownloadSync();
+  const { queue } = useDownloadStore();
+  useDownloadSync();
 
   // Apply Theme and Colors
   useEffect(() => {
@@ -264,7 +267,6 @@ export default function Video() {
     } else {
       document.documentElement.classList.remove("dark");
     }
-
     document.documentElement.setAttribute("data-color", primaryColor);
 
     if (theme === "dark") {
@@ -278,79 +280,6 @@ export default function Video() {
     GetDownloadsPath().then(setDownloadsPath);
     GetVersion().then(setVersion);
   }, []);
-  // Debounce for typed input (shorter ? 400ms is enough to avoid per-keystroke calls)
-  const debouncedUrl = useDebounce(url, 400);
-
-  // Detect if a URL is a supported video platform link
-  const isSupportedUrl = (u: string) =>
-    u.includes("youtube.com") ||
-    u.includes("youtu.be") ||
-    u.includes("tiktok.com") ||
-    u.includes("instagram.com");
-
-  // Ref to skip debounce when URL was pasted (not typed)
-  const skipDebounceRef = useRef(false);
-
-  const handlePaste = async () => {
-    try {
-      const text = await navigator.clipboard.readText();
-      if (text) {
-        setUrl(text);
-        if (error) setError("");
-
-        // Bypass debounce: fetch immediately on paste if valid URL
-        if (isSupportedUrl(text)) {
-          skipDebounceRef.current = true;
-        }
-      }
-    } catch (err) {
-      console.error("Failed to read clipboard:", err);
-    }
-  };
-
-  // Instant fetch when URL is pasted (bypasses debounce)
-  useEffect(() => {
-    if (skipDebounceRef.current) {
-      skipDebounceRef.current = false;
-      fetchVideoInfo();
-    }
-    // eslint-disable-next-line react-hooks/exhaustive-deps
-  }, [url]);
-
-  // Debounced fetch for typed URLs
-  useEffect(() => {
-    if (!debouncedUrl.trim()) {
-      setVideoInfo(null);
-      return;
-    }
-    if (!isSupportedUrl(debouncedUrl)) return;
-
-    // Don't double-fetch if paste already triggered it
-    if (isFetching) return;
-
-    fetchVideoInfo();
-    // eslint-disable-next-line react-hooks/exhaustive-deps
-  }, [debouncedUrl]);
-
-  const fetchVideoInfo = async () => {
-    if (!url.trim()) return;
-    setIsFetching(true);
-    setError("");
-    setStreamUrl("");
-    setTrimEnabled(false);
-    setTrimStart("");
-    setTrimEnd("");
-
-    try {
-      const info = await GetVideoInfo(url);
-      setVideoInfo(info as unknown as VideoInfo);
-    } catch (err) {
-      setError(String(err));
-      setVideoInfo(null);
-    } finally {
-      setIsFetching(false);
-    }
-  };
 
   // Auto-select best available quality
   useEffect(() => {
@@ -373,7 +302,7 @@ export default function Video() {
     }
   }, [videoInfo, VIDEO_QUALITIES, selectedQuality]);
 
-  const handleDownload = async () => {
+  const handleDownload = useCallback(async () => {
     if (!url.trim() || !videoInfo) return;
     setIsLoading(true);
     setError("");
@@ -400,141 +329,39 @@ export default function Video() {
         startTime: trimEnabled ? trimStart : "",
         endTime: trimEnabled ? trimEnd : "",
       });
-      setUrl("");
-      setVideoInfo(null);
+      clearUrlState();
+      resetTrimmer();
     } catch (err) {
       setError(String(err));
     } finally {
       setIsLoading(false);
     }
-  };
-
-  // Find best muxed (video+audio) format URL for preview.
-  // Prefers small (360p) MP4 ? preview doesn't need HD.
-  const findBestMuxedUrl = (): string | null => {
-    if (!videoInfo?.formats) return null;
-    const muxed = videoInfo.formats.filter(
-      (f) =>
-        f.url &&
-        f.vcodec &&
-        f.vcodec !== "none" &&
-        f.acodec &&
-        f.acodec !== "none",
-    );
-    if (muxed.length === 0) return null;
-
-    const mp4s = muxed
-      .filter((f) => f.ext === "mp4")
-      .sort((a, b) => (a.height || 0) - (b.height || 0));
-    const best = mp4s.find((f) => (f.height || 0) >= 240) || mp4s[0];
-    return best?.url || muxed[0]?.url || null;
-  };
-
-  // Ref to track blob upgrade abort controller
-  const blobAbortRef = useRef<AbortController | null>(null);
-
-  // Phase 1: Show video via proxy (instant streaming)
-  // Phase 2: Download blob in background, swap src when ready (instant seeking)
-  const handleTrimToggle = async (enabled: boolean) => {
-    setTrimEnabled(enabled);
-    streamFallbackTriedRef.current = false;
-
-    // Abort any pending blob download
-    blobAbortRef.current?.abort();
-    blobAbortRef.current = null;
-
-    if (enabled && url && !streamUrl) {
-      // Phase 1: stream via proxy ? video appears immediately
-      const muxedUrl = findBestMuxedUrl();
-      if (muxedUrl) {
-        try {
-          const proxyUrl = await SetStreamURL(muxedUrl);
-          setStreamUrl(proxyUrl);
-
-          // Phase 2: download blob in background for instant seeking
-          const controller = new AbortController();
-          blobAbortRef.current = controller;
-          fetch(proxyUrl, { signal: controller.signal })
-            .then((r) => (r.ok ? r.blob() : Promise.reject()))
-            .then((blob) => {
-              if (!controller.signal.aborted) {
-                const blobUrl = URL.createObjectURL(blob);
-                setStreamUrl((prev) => {
-                  // Revoke old proxy URL is not needed (not a blob)
-                  return blobUrl;
-                });
-              }
-            })
-            .catch(() => {});
-          return;
-        } catch {
-          // Fall through to yt-dlp
-        }
-      }
-
-      // Fallback: yt-dlp extraction ? proxy stream ? blob upgrade
-      setIsLoadingStream(true);
-      try {
-        const proxyUrl = await GetStreamURL(url, "best[ext=mp4]/best");
-        setStreamUrl(proxyUrl);
-
-        const controller = new AbortController();
-        blobAbortRef.current = controller;
-        fetch(proxyUrl, { signal: controller.signal })
-          .then((r) => (r.ok ? r.blob() : Promise.reject()))
-          .then((blob) => {
-            if (!controller.signal.aborted) {
-              setStreamUrl(URL.createObjectURL(blob));
-            }
-          })
-          .catch(() => {});
-      } catch {
-        setStreamUrl("");
-      } finally {
-        setIsLoadingStream(false);
-      }
-    }
-  };
-
-  // Called by VideoTrimmer when the video fails to load ? retry with full yt-dlp
-  const handleStreamError = async () => {
-    if (streamFallbackTriedRef.current || !url) return;
-    streamFallbackTriedRef.current = true;
-
-    if (streamUrl.startsWith("blob:")) URL.revokeObjectURL(streamUrl);
-    blobAbortRef.current?.abort();
-
-    setIsLoadingStream(true);
-    try {
-      const proxyUrl = await GetStreamURL(url, "best[ext=mp4]/best");
-      setStreamUrl(proxyUrl);
-    } catch {
-      setStreamUrl("");
-    } finally {
-      setIsLoadingStream(false);
-    }
-  };
-
-  const handleTrimChange = (start: string, end: string) => {
-    setTrimStart(start);
-    setTrimEnd(end);
-  };
-
-  const clearUrl = () => {
-    setUrl("");
-    setVideoInfo(null);
-    setError("");
-    setTrimEnabled(false);
-    setTrimStart("");
-    setTrimEnd("");
-    blobAbortRef.current?.abort();
-    blobAbortRef.current = null;
-    if (streamUrl.startsWith("blob:")) URL.revokeObjectURL(streamUrl);
-    setStreamUrl("");
-    streamFallbackTriedRef.current = false;
-  };
-
-  const formatDuration = (seconds: number) => {
+  }, [
+    url,
+    videoInfo,
+    downloadMode,
+    selectedQuality,
+    selectedAudioFormat,
+    remuxVideo,
+    remuxFormat,
+    embedThumbnail,
+    skipExisting,
+    useAria2c,
+    aria2cConnections,
+    trimEnabled,
+    trimStart,
+    trimEnd,
+    clearUrlState,
+    resetTrimmer,
+    setError,
+  ]);
+
+  const clearUrl = useCallback(() => {
+    clearUrlState();
+    resetTrimmer();
+  }, [clearUrlState, resetTrimmer]);
+
+  const formatDuration = useCallback((seconds: number) => {
     if (!seconds) return "";
     const hrs = Math.floor(seconds / 3600);
     const mins = Math.floor((seconds % 3600) / 60);
@@ -545,14 +372,21 @@ export default function Video() {
         .padStart(2, "0")}`;
     }
     return `${mins}:${secs.toString().padStart(2, "0")}`;
-  };
+  }, []);
 
-  const formatViews = (count: number) => {
+  const formatViews = useCallback((count: number) => {
     if (!count) return "";
     if (count >= 1000000) return `${(count / 1000000).toFixed(1)}M`;
     if (count >= 1000) return `${(count / 1000).toFixed(1)}K`;
     return count.toString();
-  };
+  }, []);
+
+  // Memoized available qualities based on video info
+  const availableQualities = useMemo(() => {
+    if (!videoInfo?.formats) return VIDEO_QUALITIES;
+    const maxH = Math.max(...videoInfo.formats.map((f) => f.height || 0));
+    return VIDEO_QUALITIES.filter((q) => maxH >= (q.minHeight || 0));
+  }, [videoInfo, VIDEO_QUALITIES]);
 
   return (
     <div className="flex flex-col h-screen overflow-hidden bg-surface-50 dark:bg-surface-50 text-surface-900 transition-colors duration-300">
@@ -586,38 +420,22 @@ export default function Video() {
           <AnimatePresence mode="wait">
             {activeTab === "home" && (
               <TabContent key="home">
-                <Suspense
-                  fallback={
-                    <div className="flex-1 flex items-center justify-center">
-                      <IconLoader2
-                        size={32}
-                        className="animate-spin text-primary-500"
-                      />
-                    </div>
-                  }
-                >
-                  <Dashboard onNavigate={setActiveTab} />
-                </Suspense>
+                <RouteErrorBoundary>
+                  <Suspense fallback={SuspenseFallback}>
+                    <Dashboard onNavigate={setActiveTab} />
+                  </Suspense>
+                </RouteErrorBoundary>
               </TabContent>
             )}
 
             {activeTab === "images" && enabledFeatures.includes("images") && (
               <TabContent key="images">
-                <div
-                  className="flex-1 min-h-0 overflow-y-auto p-8 bg-surface-50 dark:bg-surface-950"
-                >
-                  <Suspense
-                    fallback={
-                      <div className="flex-1 flex items-center justify-center">
-                        <IconLoader2
-                          size={32}
-                          className="animate-spin text-primary-500"
-                        />
-                      </div>
-                    }
-                  >
-                    <Images />
-                  </Suspense>
+                <div className="flex-1 min-h-0 overflow-y-auto p-8 bg-surface-50 dark:bg-surface-950">
+                  <RouteErrorBoundary>
+                    <Suspense fallback={SuspenseFallback}>
+                      <Images />
+                    </Suspense>
+                  </RouteErrorBoundary>
                 </div>
               </TabContent>
             )}
@@ -625,53 +443,32 @@ export default function Video() {
             {activeTab === "converter" &&
               enabledFeatures.includes("converter") && (
                 <TabContent key="converter">
-                  <Suspense
-                    fallback={
-                      <div className="flex-1 flex items-center justify-center">
-                        <IconLoader2
-                          size={32}
-                          className="animate-spin text-primary-500"
-                        />
-                      </div>
-                    }
-                  >
-                    <Converter />
-                  </Suspense>
+                  <RouteErrorBoundary>
+                    <Suspense fallback={SuspenseFallback}>
+                      <Converter />
+                    </Suspense>
+                  </RouteErrorBoundary>
                 </TabContent>
               )}
 
             {activeTab === "transcriber" &&
               enabledFeatures.includes("transcriber") && (
                 <TabContent key="transcriber">
-                  <Suspense
-                    fallback={
-                      <div className="flex-1 flex items-center justify-center">
-                        <IconLoader2
-                          size={32}
-                          className="animate-spin text-primary-500"
-                        />
-                      </div>
-                    }
-                  >
-                    <Transcriber />
-                  </Suspense>
+                  <RouteErrorBoundary>
+                    <Suspense fallback={SuspenseFallback}>
+                      <Transcriber />
+                    </Suspense>
+                  </RouteErrorBoundary>
                 </TabContent>
               )}
 
             {activeTab === "roadmap" && (
               <TabContent key="roadmap">
-                <Suspense
-                  fallback={
-                    <div className="flex-1 flex items-center justify-center">
-                      <IconLoader2
-                        size={32}
-                        className="animate-spin text-primary-500"
-                      />
-                    </div>
-                  }
-                >
-                  <Roadmap />
-                </Suspense>
+                <RouteErrorBoundary>
+                  <Suspense fallback={SuspenseFallback}>
+                    <Roadmap />
+                  </Suspense>
+                </RouteErrorBoundary>
               </TabContent>
             )}
 
@@ -695,10 +492,7 @@ export default function Video() {
                               if (error) setError("");
                             }}
                             onPaste={(e) => {
-                              const text = e.clipboardData.getData("text");
-                              if (text && isSupportedUrl(text)) {
-                                skipDebounceRef.current = true;
-                              }
+                              onPasteEvent(e.clipboardData.getData("text"));
                             }}
                             placeholder={t("home.paste_url")}
                             className="w-full bg-transparent border-none py-3 pl-12 pr-10 text-surface-900 placeholder:text-surface-400 focus:ring-0 text-base font-medium"
@@ -820,9 +614,7 @@ export default function Video() {
                   </div>
                 </header>
 
-                <div
-                  className="flex-1 min-h-0 overflow-y-auto p-6 custom-scrollbar"
-                >
+                <div className="flex-1 min-h-0 overflow-y-auto p-6 custom-scrollbar">
                   <div className="max-w-4xl mx-auto">
                     {/* Video Content */}
                     <AnimatePresence mode="wait">
@@ -842,6 +634,7 @@ export default function Video() {
                                   src={videoInfo.thumbnail}
                                   alt={videoInfo.title}
                                   className="w-full h-full object-cover"
+                                  loading="lazy"
                                   onError={(e) => {
                                     (
                                       e.target as HTMLImageElement
@@ -911,16 +704,7 @@ export default function Video() {
                                 {t("home.quality")}
                               </label>
                               <div className="flex gap-2 overflow-x-auto pb-1">
-                                {VIDEO_QUALITIES.filter((q) => {
-                                  const maxH = videoInfo?.formats
-                                    ? Math.max(
-                                        ...videoInfo.formats.map(
-                                          (f) => f.height || 0,
-                                        ),
-                                      )
-                                    : 0;
-                                  return maxH >= (q.minHeight || 0);
-                                }).map((q) => {
+                                {availableQualities.map((q) => {
                                   const Icon = q.icon;
                                   return (
                                     <button
@@ -993,7 +777,7 @@ export default function Video() {
                             </motion.div>
                           )}
 
-                          {/* Video Trimmer */}
+                          {/* Video Trimmer ? isolated state, won't re-render parent */}
                           {videoInfo.duration > 0 && (
                             <div className="mb-5 pt-5 border-t border-surface-100 dark:border-surface-800">
                               <VideoTrimmer
@@ -1110,9 +894,7 @@ export default function Video() {
 
             {activeTab === "history" && (
               <TabContent key="history">
-                <div
-                  className="flex-1 min-h-0 p-6 overflow-y-auto overscroll-y-contain custom-scrollbar"
-                >
+                <div className="flex-1 min-h-0 p-6 overflow-y-auto overscroll-y-contain custom-scrollbar">
                   <HistoryView />
                 </div>
               </TabContent>
diff --git a/frontend/vite.config.ts b/frontend/vite.config.ts
index 2dfac01..ba80c11 100644
--- a/frontend/vite.config.ts
+++ b/frontend/vite.config.ts
@@ -32,12 +32,25 @@ export default defineConfig({
     rollupOptions: {
       output: {
         manualChunks: {
-          "react-vendor": ["react", "react-dom", "react-router-dom"],
-          "ui-vendor": ["framer-motion", "@tabler/icons-react"],
-          "utils-vendor": ["i18next", "react-i18next", "zustand"],
+          // Core React ? loaded on every page, small and stable
+          "react-core": ["react", "react-dom"],
+          // State & i18n ? loaded on every page but separate from React for caching
+          "state-vendor": ["zustand", "i18next", "react-i18next"],
+          // Framer Motion ? heavy (~66KB gzip), isolated so lazy pages don't pay upfront
+          "motion-vendor": ["framer-motion"],
+          // Icons ? tree-shaken but still heavy, separate chunk for better caching
+          "icons-vendor": ["@tabler/icons-react"],
         },
       },
     },
-    chunkSizeWarningLimit: 1000,
+    chunkSizeWarningLimit: 600,
+    // Remove console.log in production builds
+    minify: "terser",
+    terserOptions: {
+      compress: {
+        drop_console: true,
+        drop_debugger: true,
+      },
+    },
   },
 });
diff --git a/internal/auth/service.go b/internal/auth/service.go
index f9633f6..998559c 100644
--- a/internal/auth/service.go
+++ b/internal/auth/service.go
@@ -18,6 +18,11 @@ import (
 // Device Flow habilitado nas configura??es do App
 const ClientID = "Iv23liJjoBb3O4FatgRC"
 
+// authHTTPClient is a shared HTTP client with timeout for all auth requests.
+var authHTTPClient = &http.Client{
+	Timeout: 15 * time.Second,
+}
+
 type AuthService struct {
 	configDir    string
 	Token        string
@@ -68,7 +73,7 @@ func (s *AuthService) StartDeviceFlow() (*DeviceCodeResponse, error) {
 	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
 	req.Header.Set("Accept", "application/json")
 
-	resp, err := http.DefaultClient.Do(req)
+	resp, err := authHTTPClient.Do(req)
 	if err != nil {
 		return nil, fmt.Errorf("network error: %w", err)
 	}
@@ -146,7 +151,7 @@ func (s *AuthService) checkToken(deviceCode string) (string, error) {
 	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
 	req.Header.Set("Accept", "application/json")
 
-	resp, err := http.DefaultClient.Do(req)
+	resp, err := authHTTPClient.Do(req)
 	if err != nil {
 		return "", fmt.Errorf("network error: %w", err)
 	}
@@ -223,7 +228,7 @@ func (s *AuthService) RefreshAccessToken() (string, error) {
 	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
 	req.Header.Set("Accept", "application/json")
 
-	resp, err := http.DefaultClient.Do(req)
+	resp, err := authHTTPClient.Do(req)
 	if err != nil {
 		return "", fmt.Errorf("network error during refresh: %w", err)
 	}
diff --git a/internal/downloader/manager.go b/internal/downloader/manager.go
index 6440947..39ae922 100644
--- a/internal/downloader/manager.go
+++ b/internal/downloader/manager.go
@@ -38,6 +38,11 @@ type Manager struct {
 	// Metrics
 	totalCompleted int64
 	totalFailed    int64
+
+	// Batched progress: stores latest progress per job, flushed every 50ms
+	pendingProgress map[string]map[string]interface{}
+	progressMu      sync.Mutex
+	progressTicker  *time.Ticker
 }
 
 // NewManager creates a new download manager
@@ -47,13 +52,14 @@ func NewManager(repo *storage.DownloadRepository, client *youtube.Client, maxCon
 	}
 
 	return &Manager{
-		repo:          repo,
-		client:        client,
-		maxConcurrent: maxConcurrent,
-		queue:         make(chan *Job, 100), // Buffered to not block UI
-		activeSlots:   make(chan struct{}, maxConcurrent),
-		jobs:          make(map[string]*Job),
-		quit:          make(chan struct{}),
+		repo:            repo,
+		client:          client,
+		maxConcurrent:   maxConcurrent,
+		queue:           make(chan *Job, 100), // Buffered to not block UI
+		activeSlots:     make(chan struct{}, maxConcurrent),
+		jobs:            make(map[string]*Job),
+		quit:            make(chan struct{}),
+		pendingProgress: make(map[string]map[string]interface{}),
 	}
 }
 
@@ -72,6 +78,10 @@ func (m *Manager) Start() {
 	// Periodic stats logging
 	go m.logStatsLoop()
 
+	// Batched progress flush loop (50ms window to reduce frontend event thrashing)
+	m.progressTicker = time.NewTicker(50 * time.Millisecond)
+	go m.flushProgressLoop()
+
 	// Main processing loop
 	go func() {
 		for {
@@ -98,6 +108,10 @@ func (m *Manager) Start() {
 // Stop gracefully shuts down the manager
 func (m *Manager) Stop() {
 	close(m.quit)
+	if m.progressTicker != nil {
+		m.progressTicker.Stop()
+	}
+	m.flushPendingProgress() // Flush remaining progress events
 	m.wg.Wait()
 	logger.Log.Info().Msg("download manager stopped")
 }
@@ -453,9 +467,12 @@ func (m *Manager) logStatsLoop() {
 	}
 }
 
-// emitEvent is a helper to emit events using Wails v3 API
+// emitEvent is a helper to emit events using Wails v3 API.
+// Safe for tests where application.Get() may return nil.
 func (m *Manager) emitEvent(eventName string, data any) {
-	application.Get().Event.Emit(eventName, data)
+	if app := application.Get(); app != nil {
+		app.Event.Emit(eventName, data)
+	}
 }
 
 // emitJobAdded emits an event when a job is added
@@ -476,7 +493,8 @@ func (m *Manager) emitProgress(download *storage.Download) {
 	})
 }
 
-// emitDetailedProgress emite progresso com ID do job (para callbacks)
+// emitDetailedProgress buffers progress updates to be flushed every 50ms.
+// This reduces frontend event thrashing during rapid yt-dlp output.
 func (m *Manager) emitDetailedProgress(jobID string, p youtube.DownloadProgress) {
 	m.mu.RLock()
 	job, exists := m.jobs[jobID]
@@ -487,14 +505,52 @@ func (m *Manager) emitDetailedProgress(jobID string, p youtube.DownloadProgress)
 		thumbnail = job.Download.Thumbnail
 	}
 
-	m.emitEvent(events.DownloadProgress, map[string]interface{}{
+	data := map[string]interface{}{
 		"id":        jobID,
 		"status":    p.Status,
 		"progress":  p.Percent,
 		"speed":     p.Speed,
 		"eta":       p.ETA,
 		"thumbnail": thumbnail,
-	})
+	}
+
+	// For terminal states, emit immediately (don't buffer)
+	if p.Status == "merging" || p.Status == "completed" || p.Status == "failed" {
+		m.emitEvent(events.DownloadProgress, data)
+		return
+	}
+
+	m.progressMu.Lock()
+	m.pendingProgress[jobID] = data
+	m.progressMu.Unlock()
+}
+
+// flushProgressLoop periodically sends batched progress to frontend
+func (m *Manager) flushProgressLoop() {
+	for {
+		select {
+		case <-m.progressTicker.C:
+			m.flushPendingProgress()
+		case <-m.quit:
+			return
+		}
+	}
+}
+
+// flushPendingProgress emits all buffered progress events
+func (m *Manager) flushPendingProgress() {
+	m.progressMu.Lock()
+	if len(m.pendingProgress) == 0 {
+		m.progressMu.Unlock()
+		return
+	}
+	pending := m.pendingProgress
+	m.pendingProgress = make(map[string]map[string]interface{})
+	m.progressMu.Unlock()
+
+	for _, data := range pending {
+		m.emitEvent(events.DownloadProgress, data)
+	}
 }
 
 // emitLog emite log com ID do job (para Terminal)
diff --git a/internal/downloader/manager_test.go b/internal/downloader/manager_test.go
index b3e9c92..65d3465 100644
--- a/internal/downloader/manager_test.go
+++ b/internal/downloader/manager_test.go
@@ -44,13 +44,14 @@ func TestManager_AddJob_CreatesDownload(t *testing.T) {
 
 	// Create manager but don't start the worker loop (we test AddJob logic only)
 	m := &Manager{
-		ctx:           context.Background(),
-		repo:          repo,
-		maxConcurrent: 3,
-		queue:         make(chan *Job, 100),
-		activeSlots:   make(chan struct{}, 3),
-		jobs:          make(map[string]*Job),
-		quit:          make(chan struct{}),
+		ctx:             context.Background(),
+		repo:            repo,
+		maxConcurrent:   3,
+		queue:           make(chan *Job, 100),
+		activeSlots:     make(chan struct{}, 3),
+		jobs:            make(map[string]*Job),
+		quit:            make(chan struct{}),
+		pendingProgress: make(map[string]map[string]interface{}),
 	}
 
 	opts := youtube.DownloadOptions{
@@ -93,13 +94,14 @@ func TestManager_AddJob_CreatesDownload(t *testing.T) {
 func TestManager_AddJob_PreventsDuplicateURL(t *testing.T) {
 	repo := testRepo(t)
 	m := &Manager{
-		ctx:           context.Background(),
-		repo:          repo,
-		maxConcurrent: 3,
-		queue:         make(chan *Job, 100),
-		activeSlots:   make(chan struct{}, 3),
-		jobs:          make(map[string]*Job),
-		quit:          make(chan struct{}),
+		ctx:             context.Background(),
+		repo:            repo,
+		maxConcurrent:   3,
+		queue:           make(chan *Job, 100),
+		activeSlots:     make(chan struct{}, 3),
+		jobs:            make(map[string]*Job),
+		quit:            make(chan struct{}),
+		pendingProgress: make(map[string]map[string]interface{}),
 	}
 
 	url := "https://youtube.com/watch?v=dup"
@@ -124,13 +126,14 @@ func TestManager_AddJob_PreventsDuplicateURL(t *testing.T) {
 func TestManager_AddJob_ConcurrentSafety(t *testing.T) {
 	repo := testRepo(t)
 	m := &Manager{
-		ctx:           context.Background(),
-		repo:          repo,
-		maxConcurrent: 3,
-		queue:         make(chan *Job, 100),
-		activeSlots:   make(chan struct{}, 3),
-		jobs:          make(map[string]*Job),
-		quit:          make(chan struct{}),
+		ctx:             context.Background(),
+		repo:            repo,
+		maxConcurrent:   3,
+		queue:           make(chan *Job, 100),
+		activeSlots:     make(chan struct{}, 3),
+		jobs:            make(map[string]*Job),
+		quit:            make(chan struct{}),
+		pendingProgress: make(map[string]map[string]interface{}),
 	}
 
 	var wg sync.WaitGroup
@@ -172,13 +175,14 @@ func TestManager_AddJob_ConcurrentSafety(t *testing.T) {
 func TestManager_CancelJob_UpdatesStatus(t *testing.T) {
 	repo := testRepo(t)
 	m := &Manager{
-		ctx:           context.Background(),
-		repo:          repo,
-		maxConcurrent: 3,
-		queue:         make(chan *Job, 100),
-		activeSlots:   make(chan struct{}, 3),
-		jobs:          make(map[string]*Job),
-		quit:          make(chan struct{}),
+		ctx:             context.Background(),
+		repo:            repo,
+		maxConcurrent:   3,
+		queue:           make(chan *Job, 100),
+		activeSlots:     make(chan struct{}, 3),
+		jobs:            make(map[string]*Job),
+		quit:            make(chan struct{}),
+		pendingProgress: make(map[string]map[string]interface{}),
 	}
 
 	download, _ := m.AddJob(youtube.DownloadOptions{URL: "https://youtube.com/watch?v=cancel-test"})
@@ -198,13 +202,14 @@ func TestManager_CancelJob_UpdatesStatus(t *testing.T) {
 func TestManager_CancelJob_CancelsContext(t *testing.T) {
 	repo := testRepo(t)
 	m := &Manager{
-		ctx:           context.Background(),
-		repo:          repo,
-		maxConcurrent: 3,
-		queue:         make(chan *Job, 100),
-		activeSlots:   make(chan struct{}, 3),
-		jobs:          make(map[string]*Job),
-		quit:          make(chan struct{}),
+		ctx:             context.Background(),
+		repo:            repo,
+		maxConcurrent:   3,
+		queue:           make(chan *Job, 100),
+		activeSlots:     make(chan struct{}, 3),
+		jobs:            make(map[string]*Job),
+		quit:            make(chan struct{}),
+		pendingProgress: make(map[string]map[string]interface{}),
 	}
 
 	download, _ := m.AddJob(youtube.DownloadOptions{URL: "https://youtube.com/watch?v=ctx-cancel"})
@@ -236,13 +241,14 @@ func TestManager_CancelJob_CancelsContext(t *testing.T) {
 func TestManager_CancelJob_NonExistentJob(t *testing.T) {
 	repo := testRepo(t)
 	m := &Manager{
-		ctx:           context.Background(),
-		repo:          repo,
-		maxConcurrent: 3,
-		queue:         make(chan *Job, 100),
-		activeSlots:   make(chan struct{}, 3),
-		jobs:          make(map[string]*Job),
-		quit:          make(chan struct{}),
+		ctx:             context.Background(),
+		repo:            repo,
+		maxConcurrent:   3,
+		queue:           make(chan *Job, 100),
+		activeSlots:     make(chan struct{}, 3),
+		jobs:            make(map[string]*Job),
+		quit:            make(chan struct{}),
+		pendingProgress: make(map[string]map[string]interface{}),
 	}
 
 	// Should not panic, just update DB status (even if no record)
@@ -260,13 +266,14 @@ func TestManager_CancelJob_NonExistentJob(t *testing.T) {
 func TestManager_GetQueue(t *testing.T) {
 	repo := testRepo(t)
 	m := &Manager{
-		ctx:           context.Background(),
-		repo:          repo,
-		maxConcurrent: 3,
-		queue:         make(chan *Job, 100),
-		activeSlots:   make(chan struct{}, 3),
-		jobs:          make(map[string]*Job),
-		quit:          make(chan struct{}),
+		ctx:             context.Background(),
+		repo:            repo,
+		maxConcurrent:   3,
+		queue:           make(chan *Job, 100),
+		activeSlots:     make(chan struct{}, 3),
+		jobs:            make(map[string]*Job),
+		quit:            make(chan struct{}),
+		pendingProgress: make(map[string]map[string]interface{}),
 	}
 
 	m.AddJob(youtube.DownloadOptions{URL: "https://youtube.com/watch?v=q1"})
@@ -284,13 +291,14 @@ func TestManager_GetQueue(t *testing.T) {
 func TestManager_GetHistory_Empty(t *testing.T) {
 	repo := testRepo(t)
 	m := &Manager{
-		ctx:           context.Background(),
-		repo:          repo,
-		maxConcurrent: 3,
-		queue:         make(chan *Job, 100),
-		activeSlots:   make(chan struct{}, 3),
-		jobs:          make(map[string]*Job),
-		quit:          make(chan struct{}),
+		ctx:             context.Background(),
+		repo:            repo,
+		maxConcurrent:   3,
+		queue:           make(chan *Job, 100),
+		activeSlots:     make(chan struct{}, 3),
+		jobs:            make(map[string]*Job),
+		quit:            make(chan struct{}),
+		pendingProgress: make(map[string]map[string]interface{}),
 	}
 
 	history, err := m.GetHistory(50)
@@ -305,13 +313,14 @@ func TestManager_GetHistory_Empty(t *testing.T) {
 func TestManager_ClearHistory(t *testing.T) {
 	repo := testRepo(t)
 	m := &Manager{
-		ctx:           context.Background(),
-		repo:          repo,
-		maxConcurrent: 3,
-		queue:         make(chan *Job, 100),
-		activeSlots:   make(chan struct{}, 3),
-		jobs:          make(map[string]*Job),
-		quit:          make(chan struct{}),
+		ctx:             context.Background(),
+		repo:            repo,
+		maxConcurrent:   3,
+		queue:           make(chan *Job, 100),
+		activeSlots:     make(chan struct{}, 3),
+		jobs:            make(map[string]*Job),
+		quit:            make(chan struct{}),
+		pendingProgress: make(map[string]map[string]interface{}),
 	}
 
 	// Create and complete a download manually in DB
@@ -367,13 +376,14 @@ func TestNewManager_DefaultsConcurrency(t *testing.T) {
 func TestManager_CleanupJob(t *testing.T) {
 	repo := testRepo(t)
 	m := &Manager{
-		ctx:           context.Background(),
-		repo:          repo,
-		maxConcurrent: 3,
-		queue:         make(chan *Job, 100),
-		activeSlots:   make(chan struct{}, 3),
-		jobs:          make(map[string]*Job),
-		quit:          make(chan struct{}),
+		ctx:             context.Background(),
+		repo:            repo,
+		maxConcurrent:   3,
+		queue:           make(chan *Job, 100),
+		activeSlots:     make(chan struct{}, 3),
+		jobs:            make(map[string]*Job),
+		quit:            make(chan struct{}),
+		pendingProgress: make(map[string]map[string]interface{}),
 	}
 
 	download, _ := m.AddJob(youtube.DownloadOptions{URL: "https://youtube.com/watch?v=cleanup"})
@@ -413,13 +423,14 @@ func TestManager_RestorePendingJobs(t *testing.T) {
 	repo.Create(d3)
 
 	m := &Manager{
-		ctx:           context.Background(),
-		repo:          repo,
-		maxConcurrent: 3,
-		queue:         make(chan *Job, 100),
-		activeSlots:   make(chan struct{}, 3),
-		jobs:          make(map[string]*Job),
-		quit:          make(chan struct{}),
+		ctx:             context.Background(),
+		repo:            repo,
+		maxConcurrent:   3,
+		queue:           make(chan *Job, 100),
+		activeSlots:     make(chan struct{}, 3),
+		jobs:            make(map[string]*Job),
+		quit:            make(chan struct{}),
+		pendingProgress: make(map[string]map[string]interface{}),
 	}
 
 	m.restorePendingJobs()
diff --git a/internal/handlers/video.go b/internal/handlers/video.go
index a454434..bab703f 100644
--- a/internal/handlers/video.go
+++ b/internal/handlers/video.go
@@ -41,13 +41,28 @@ type VideoHandler struct {
 
 // NewVideoHandler creates a new VideoHandler with dependencies.
 // Uses constructor injection for testability - accepts interfaces, not concrete types.
-func NewVideoHandler(yt YouTubeClientInterface, dm DownloadManagerInterface) *VideoHandler {
-	return &VideoHandler{
+// ctx and emitter can be passed directly to avoid the SetContext/SetConsoleEmitter anti-pattern.
+func NewVideoHandler(yt YouTubeClientInterface, dm DownloadManagerInterface, opts ...func(*VideoHandler)) *VideoHandler {
+	h := &VideoHandler{
 		ctx:             context.Background(),
 		youtube:         yt,
 		downloadManager: dm,
 		consoleEmitter:  func(s string) {}, // no-op default
 	}
+	for _, opt := range opts {
+		opt(h)
+	}
+	return h
+}
+
+// WithContext returns an option that sets the handler context.
+func WithContext(ctx context.Context) func(*VideoHandler) {
+	return func(h *VideoHandler) { h.ctx = ctx }
+}
+
+// WithConsoleEmitter returns an option that sets the console emitter.
+func WithConsoleEmitter(emitter func(string)) func(*VideoHandler) {
+	return func(h *VideoHandler) { h.consoleEmitter = emitter }
 }
 
 // SetContext sets the Wails runtime context.
diff --git a/internal/roadmap/service.go b/internal/roadmap/service.go
index 73d5ff0..9c98c34 100644
--- a/internal/roadmap/service.go
+++ b/internal/roadmap/service.go
@@ -85,6 +85,9 @@ type Service struct {
 	// Cached user login per token (avoids repeated /user API calls)
 	cachedUserLogin string
 	cachedUserToken string
+
+	// Shared HTTP client with connection pooling and timeout
+	httpClient *http.Client
 }
 
 // statusMapping maps GitHub Project column names to internal Status types
@@ -114,6 +117,13 @@ func NewService(owner, name string) *Service {
 		config:        cfg,
 		cdnFetcher:    NewCDNFetcher(cfg),
 		useCDN:        false, // Safe default: use direct GitHub API until config enables CDN
+		httpClient: &http.Client{
+			Timeout: 10 * time.Second,
+			Transport: &http.Transport{
+				MaxIdleConns:    10,
+				IdleConnTimeout: 90 * time.Second,
+			},
+		},
 	}
 }
 
@@ -579,8 +589,7 @@ func (s *Service) fetchFromProjects(token string) ([]RoadmapItem, error) {
 	req.Header.Set("Content-Type", "application/json")
 	req.Header.Set("User-Agent", "DownKingo-Desktop/1.0")
 
-	client := &http.Client{Timeout: 15 * time.Second}
-	resp, err := client.Do(req)
+	resp, err := s.httpClient.Do(req)
 	if err != nil {
 		return nil, fmt.Errorf("api request failed: %w", err)
 	}
@@ -801,8 +810,7 @@ func (s *Service) deleteReactionByUser(token string, issueID int, reactions []Re
 	req.Header.Set("Authorization", "Bearer "+token)
 	req.Header.Set("Accept", "application/vnd.github.v3+json")
 
-	client := &http.Client{Timeout: 10 * time.Second}
-	resp, err := client.Do(req)
+	resp, err := s.httpClient.Do(req)
 	if err != nil {
 		return err
 	}
@@ -824,8 +832,7 @@ func (s *Service) addReactionRaw(token string, issueID int, reaction string) err
 	req.Header.Set("Authorization", "Bearer "+token)
 	req.Header.Set("Accept", "application/vnd.github.v3+json")
 
-	client := &http.Client{Timeout: 10 * time.Second}
-	resp, err := client.Do(req)
+	resp, err := s.httpClient.Do(req)
 	if err != nil {
 		return err
 	}
@@ -911,8 +918,7 @@ func (s *Service) getCurrentUserLogin(token string) (string, error) {
 	req.Header.Set("Authorization", "Bearer "+token)
 	req.Header.Set("Accept", "application/vnd.github.v3+json")
 
-	client := &http.Client{Timeout: 10 * time.Second}
-	resp, err := client.Do(req)
+	resp, err := s.httpClient.Do(req)
 	if err != nil {
 		return "", err
 	}
@@ -946,8 +952,7 @@ func (s *Service) getIssueReactions(token string, issueID int) ([]Reaction, erro
 	req.Header.Set("Authorization", "Bearer "+token)
 	req.Header.Set("Accept", "application/vnd.github.squirrel-girl-preview+json")
 
-	client := &http.Client{Timeout: 10 * time.Second}
-	resp, err := client.Do(req)
+	resp, err := s.httpClient.Do(req)
 	if err != nil {
 		return nil, err
 	}
@@ -979,8 +984,7 @@ func (s *Service) CreateIssue(token, title, body string) error {
 	req.Header.Set("Authorization", "Bearer "+token)
 	req.Header.Set("Accept", "application/vnd.github.v3+json")
 
-	client := &http.Client{Timeout: 10 * time.Second}
-	resp, err := client.Do(req)
+	resp, err := s.httpClient.Do(req)
 	if err != nil {
 		return err
 	}
diff --git a/internal/storage/db.go b/internal/storage/db.go
index 1b830ea..b647b0f 100644
--- a/internal/storage/db.go
+++ b/internal/storage/db.go
@@ -35,7 +35,10 @@ func New(dataDir string) (*DB, error) {
 		"PRAGMA foreign_keys = ON",
 		"PRAGMA journal_mode = WAL",
 		"PRAGMA synchronous = NORMAL",
-		"PRAGMA cache_size = -64000", // 64MB cache
+		"PRAGMA cache_size = -64000",    // 64MB cache
+		"PRAGMA busy_timeout = 5000",    // Wait 5s on lock instead of failing immediately
+		"PRAGMA temp_store = MEMORY",    // Store temp tables in memory
+		"PRAGMA mmap_size = 268435456",  // 256MB memory-mapped I/O
 	}
 
 	for _, pragma := range pragmas {
diff --git a/internal/storage/downloads.go b/internal/storage/downloads.go
index 4bd2b08..a11f8ea 100644
--- a/internal/storage/downloads.go
+++ b/internal/storage/downloads.go
@@ -7,6 +7,13 @@ import (
 	"github.com/google/uuid"
 )
 
+// downloadColumns is the standard SELECT column list using COALESCE to avoid sql.NullString overhead.
+// This eliminates ~8 NullString allocations per row scanned.
+const downloadColumns = `id, url, COALESCE(title,''), COALESCE(thumbnail,''), duration, COALESCE(uploader,''),
+	COALESCE(format,'best'), audio_only, status, progress, COALESCE(speed,''), COALESCE(eta,''),
+	COALESCE(file_path,''), file_size, COALESCE(error_message,''),
+	created_at, started_at, completed_at`
+
 // DownloadRepository handles download CRUD operations
 type DownloadRepository struct {
 	db *DB
@@ -61,20 +68,14 @@ func (r *DownloadRepository) Update(d *Download) error {
 // ExistsActiveByURL checks if there's already an active download for this URL
 // Returns the existing download if found, nil otherwise
 func (r *DownloadRepository) ExistsActiveByURL(url string) (*Download, error) {
-	query := `
-		SELECT id, url, title, thumbnail, duration, uploader, format, audio_only,
-			status, progress, speed, eta, file_path, file_size, error_message,
-			created_at, started_at, completed_at
-		FROM downloads 
+	query := `SELECT ` + downloadColumns + ` FROM downloads
 		WHERE url = ? AND status NOT IN ('completed', 'failed', 'cancelled')
-		LIMIT 1
-	`
+		LIMIT 1`
 	d := &Download{}
-	var title, thumbnail, uploader, format, speed, eta, filePath, errorMessage sql.NullString
 	err := r.db.conn.QueryRow(query, url).Scan(
-		&d.ID, &d.URL, &title, &thumbnail, &d.Duration, &uploader,
-		&format, &d.AudioOnly, &d.Status, &d.Progress, &speed, &eta,
-		&filePath, &d.FileSize, &errorMessage,
+		&d.ID, &d.URL, &d.Title, &d.Thumbnail, &d.Duration, &d.Uploader,
+		&d.Format, &d.AudioOnly, &d.Status, &d.Progress, &d.Speed, &d.ETA,
+		&d.FilePath, &d.FileSize, &d.ErrorMessage,
 		&d.CreatedAt, &d.StartedAt, &d.CompletedAt,
 	)
 	if err == sql.ErrNoRows {
@@ -83,14 +84,6 @@ func (r *DownloadRepository) ExistsActiveByURL(url string) (*Download, error) {
 	if err != nil {
 		return nil, err
 	}
-	d.Title = title.String
-	d.Thumbnail = thumbnail.String
-	d.Uploader = uploader.String
-	d.Format = format.String
-	d.Speed = speed.String
-	d.ETA = eta.String
-	d.FilePath = filePath.String
-	d.ErrorMessage = errorMessage.String
 	return d, nil
 }
 
@@ -110,19 +103,13 @@ func (r *DownloadRepository) UpdateProgress(id string, progress float64, speed,
 
 // GetByID retrieves a download by ID
 func (r *DownloadRepository) GetByID(id string) (*Download, error) {
-	query := `
-		SELECT id, url, title, thumbnail, duration, uploader, format, audio_only,
-			status, progress, speed, eta, file_path, file_size, error_message,
-			created_at, started_at, completed_at
-		FROM downloads WHERE id = ?
-	`
+	query := `SELECT ` + downloadColumns + ` FROM downloads WHERE id = ?`
 
 	d := &Download{}
-	var title, thumbnail, uploader, format, speed, eta, filePath, errorMessage sql.NullString
 	err := r.db.conn.QueryRow(query, id).Scan(
-		&d.ID, &d.URL, &title, &thumbnail, &d.Duration, &uploader,
-		&format, &d.AudioOnly, &d.Status, &d.Progress, &speed, &eta,
-		&filePath, &d.FileSize, &errorMessage,
+		&d.ID, &d.URL, &d.Title, &d.Thumbnail, &d.Duration, &d.Uploader,
+		&d.Format, &d.AudioOnly, &d.Status, &d.Progress, &d.Speed, &d.ETA,
+		&d.FilePath, &d.FileSize, &d.ErrorMessage,
 		&d.CreatedAt, &d.StartedAt, &d.CompletedAt,
 	)
 
@@ -132,14 +119,6 @@ func (r *DownloadRepository) GetByID(id string) (*Download, error) {
 	if err != nil {
 		return nil, err
 	}
-	d.Title = title.String
-	d.Thumbnail = thumbnail.String
-	d.Uploader = uploader.String
-	d.Format = format.String
-	d.Speed = speed.String
-	d.ETA = eta.String
-	d.FilePath = filePath.String
-	d.ErrorMessage = errorMessage.String
 	return d, nil
 }
 
@@ -150,41 +129,22 @@ func (r *DownloadRepository) GetPending() ([]*Download, error) {
 
 // GetActive retrieves downloads that are currently downloading or merging
 func (r *DownloadRepository) GetActive() ([]*Download, error) {
-	query := `
-		SELECT id, url, title, thumbnail, duration, uploader, format, audio_only,
-			status, progress, speed, eta, file_path, file_size, error_message,
-			created_at, started_at, completed_at
-		FROM downloads 
-		WHERE status IN ('downloading', 'merging')
-		ORDER BY started_at ASC
-	`
+	query := `SELECT ` + downloadColumns + ` FROM downloads
+		WHERE status IN ('downloading', 'merging') ORDER BY started_at ASC`
 	return r.queryDownloads(query)
 }
 
 // GetHistory retrieves completed and failed downloads
 func (r *DownloadRepository) GetHistory(limit int) ([]*Download, error) {
-	query := `
-		SELECT id, url, title, thumbnail, duration, uploader, format, audio_only,
-			status, progress, speed, eta, file_path, file_size, error_message,
-			created_at, started_at, completed_at
-		FROM downloads 
-		WHERE status IN ('completed', 'failed', 'cancelled')
-		ORDER BY completed_at DESC
-		LIMIT ?
-	`
+	query := `SELECT ` + downloadColumns + ` FROM downloads
+		WHERE status IN ('completed', 'failed', 'cancelled') ORDER BY completed_at DESC LIMIT ?`
 	return r.queryDownloadsWithArgs(query, limit)
 }
 
 // GetQueue retrieves all non-completed downloads (pending + active)
 func (r *DownloadRepository) GetQueue() ([]*Download, error) {
-	query := `
-		SELECT id, url, title, thumbnail, duration, uploader, format, audio_only,
-			status, progress, speed, eta, file_path, file_size, error_message,
-			created_at, started_at, completed_at
-		FROM downloads 
-		WHERE status NOT IN ('completed', 'failed', 'cancelled')
-		ORDER BY created_at ASC
-	`
+	query := `SELECT ` + downloadColumns + ` FROM downloads
+		WHERE status NOT IN ('completed', 'failed', 'cancelled') ORDER BY created_at ASC`
 	return r.queryDownloads(query)
 }
 
@@ -202,13 +162,7 @@ func (r *DownloadRepository) ClearHistory() error {
 
 // getByStatus retrieves downloads with a specific status
 func (r *DownloadRepository) getByStatus(status DownloadStatus) ([]*Download, error) {
-	query := `
-		SELECT id, url, title, thumbnail, duration, uploader, format, audio_only,
-			status, progress, speed, eta, file_path, file_size, error_message,
-			created_at, started_at, completed_at
-		FROM downloads WHERE status = ?
-		ORDER BY created_at ASC
-	`
+	query := `SELECT ` + downloadColumns + ` FROM downloads WHERE status = ? ORDER BY created_at ASC`
 	return r.queryDownloadsWithArgs(query, status)
 }
 
@@ -234,30 +188,22 @@ func (r *DownloadRepository) queryDownloadsWithArgs(query string, args ...interf
 	return r.scanDownloads(rows)
 }
 
-// scanDownloads scans rows into Download structs
+// scanDownloads scans rows into Download structs.
+// Uses COALESCE in queries to avoid sql.NullString allocations (~8 per row).
 func (r *DownloadRepository) scanDownloads(rows *sql.Rows) ([]*Download, error) {
 	var downloads []*Download
 
 	for rows.Next() {
 		d := &Download{}
-		var title, thumbnail, uploader, format, speed, eta, filePath, errorMessage sql.NullString
 		err := rows.Scan(
-			&d.ID, &d.URL, &title, &thumbnail, &d.Duration, &uploader,
-			&format, &d.AudioOnly, &d.Status, &d.Progress, &speed, &eta,
-			&filePath, &d.FileSize, &errorMessage,
+			&d.ID, &d.URL, &d.Title, &d.Thumbnail, &d.Duration, &d.Uploader,
+			&d.Format, &d.AudioOnly, &d.Status, &d.Progress, &d.Speed, &d.ETA,
+			&d.FilePath, &d.FileSize, &d.ErrorMessage,
 			&d.CreatedAt, &d.StartedAt, &d.CompletedAt,
 		)
 		if err != nil {
 			return nil, err
 		}
-		d.Title = title.String
-		d.Thumbnail = thumbnail.String
-		d.Uploader = uploader.String
-		d.Format = format.String
-		d.Speed = speed.String
-		d.ETA = eta.String
-		d.FilePath = filePath.String
-		d.ErrorMessage = errorMessage.String
 		downloads = append(downloads, d)
 	}
 
diff --git a/internal/youtube/youtube.go b/internal/youtube/youtube.go
index febbf8d..a9d3792 100644
--- a/internal/youtube/youtube.go
+++ b/internal/youtube/youtube.go
@@ -48,12 +48,10 @@ func sanitizeUTF8(s string) string {
 		return s
 	}
 	// Converter byte a byte assumindo CP1252/Latin-1
-	var result []rune
+	// Pr?-aloca buffer para evitar realoca??es O(n?)
+	result := make([]rune, len(s))
 	for i := 0; i < len(s); i++ {
-		b := s[i]
-		// CP1252 bytes 0x80-0x9F t?m mapeamento especial
-		// Para simplificar, tratamos como Latin-1 (ISO-8859-1) que ? um superset de ASCII
-		result = append(result, rune(b))
+		result[i] = rune(s[i])
 	}
 	return string(result)
 }
